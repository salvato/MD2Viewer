#pragma once
//=============================
// Bullet needs some basic info
//=============================

#include <bullet/btBulletDynamicsCommon.h>
#include "PhysicsDraw.h"
#include "GameValues.h"


class PhysicsObj
{
public:
    PhysicsObj(btCollisionShape* Shape,       // To create a new object:
               float mass,                    // it needs shape and mass data
               const btVector3 &Position,     // these are defaults, but best to be replaces
               const btQuaternion &Rotation );// here be dragons...but glm and bt, can handle it

    ~PhysicsObj();

// Best to allow our Object to set and return used things in accessors
    inline btCollisionShape* GetShape(){return m_Shape;}
    inline void	SetShape(btCollisionShape* S) {m_Shape = S; }
    inline btRigidBody* GetRigidBody(){return m_Body;	}
    inline void SetRigidBody(btRigidBody* RB)	{ m_Body = RB; }
    inline btMotionState* GetMotionState() {return m_Status;}

// Couple of useful utility functions to simplify the rotate and position
// of our physics objects. These act on the Rigid body and therefore
// will reposition/orient an object while it is in the physics world,
// useful for restarting or teleporting.
    inline void SetOrientation(btQuaternion Rotation) {
// Could just m_body->setXXX but there's a slim chance you might add
// multiple rigid bodies to an object and you would make GetRigidBody
// return the active one, so this is a safer method to allow for later expansion
        GetRigidBody()->setWorldTransform(btTransform(Rotation, m_Body->getWorldTransform().getOrigin()));
    }

    inline void SetPosition(btVector3 Position) {
        GetRigidBody()->setWorldTransform(btTransform(m_Body->getOrientation(), Position));
    }

// This gets the Motionstate transform, which is a useful variables
// made available after the step.
// As these are generated by the step system, they should be used
// as read only, as writing to them  has no effect and sending them back
// to the motionstate is not useful,
    void GetTransform(btScalar* transform) {
        if (m_Status)
            m_Status->GetWorldTransform(transform); //this is the important part
    }

protected:
    btRigidBody* m_Body;
    btCollisionShape* m_Shape;
// The general position, orientation and scale of our object to return back
    GameValues* m_Status;
};
